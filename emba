#!/bin/bash -p
# see: https://developer.apple.com/library/archive/documentation/OpenSource/Conceptual/ShellScripting/ShellScriptSecurity/ShellScriptSecurity.html#//apple_ref/doc/uid/TP40004268-CH8-SW29

# EMBA - EMBEDDED LINUX ANALYZER
#
# Copyright 2020-2023 Siemens AG
# Copyright 2020-2023 Siemens Energy AG
#
# EMBA comes with ABSOLUTELY NO WARRANTY. This is free software, and you are
# welcome to redistribute it under the terms of the GNU General Public License.
# See LICENSE file for usage of this software.
#
# EMBA is licensed under GPLv3
#
# Author(s): Michael Messner, Pascal Eckmann
# Contributor(s): Stefan Haboeck

# Description:  Main script for load all necessary files and call main function of modules

INVOCATION_PATH="."
MODULE_COUNT=0

import_helper()
{
  local HELPERS=()
  local HELPER_COUNT=0
  local HELPER_FILE=""
  mapfile -d '' HELPERS < <(find "${HELP_DIR}" -iname "helpers_emba_*.sh" -print0 2> /dev/null)
  for HELPER_FILE in "${HELPERS[@]}" ; do
    if ( file "${HELPER_FILE}" | grep -q "shell script" ) && ! [[ "${HELPER_FILE}" =~ \ |\' ]] ; then
      # https://github.com/koalaman/shellcheck/wiki/SC1090
      # shellcheck source=/dev/null
      source "${HELPER_FILE}"
      (( HELPER_COUNT+=1 ))
    fi
  done
  print_output "==> ""${GREEN}""Imported ""${HELPER_COUNT}"" helper files""${NC}" "no_log"
}

import_module()
{
  local MODULES=()
  local MODULES_LOCAL=()
  local MODULES_EMBA=()
  local MODULE_COUNT=0
  local MODULE_FILE=""
  # to ensure we are only auto load modules from the modules main directory we set maxdepth
  # with this in place we can create sub directories per module. For using/loading stuff from
  # these sub directories the modules are responsible!
  mapfile -t MODULES_EMBA < <(find "${MOD_DIR}" -maxdepth 1 -name "*.sh" | sort -V 2> /dev/null)
  if [[ -d "${MOD_DIR_LOCAL}" ]]; then
    mapfile -t MODULES_LOCAL < <(find "${MOD_DIR_LOCAL}" -maxdepth 1 -name "*.sh" 2>/dev/null | sort -V 2> /dev/null)
  fi
  MODULES=( "${MODULES_EMBA[@]}" "${MODULES_LOCAL[@]}" )
  for MODULE_FILE in "${MODULES[@]}" ; do
    if ( file "${MODULE_FILE}" | grep -q "shell script" ) && ! [[ "${MODULE_FILE}" =~ \ |\' ]] ; then
      # https://github.com/koalaman/shellcheck/wiki/SC1090
      # shellcheck source=/dev/null
      source "${MODULE_FILE}"
      (( MODULE_COUNT+=1 ))
    fi
  done
  print_output "==> ""${GREEN}""Imported ""${MODULE_COUNT}"" module/s""${NC}" "no_log"
}

sort_modules()
{
  local SORTED_MODULES=()
  local MODULE_FILE=""
  for MODULE_FILE in "${MODULES[@]}" ; do
    if ( file "${MODULE_FILE}" | grep -q "shell script" ) && ! [[ "${MODULE_FILE}" =~ \ |\' ]] ; then
      THREAD_PRIO=0
      # https://github.com/koalaman/shellcheck/wiki/SC1090
      # shellcheck source=/dev/null
      source "${MODULE_FILE}"
      if [[ ${THREAD_PRIO} -eq 1 ]] ; then
        SORTED_MODULES=( "${MODULE_FILE}" "${SORTED_MODULES[@]}" )
      else
        SORTED_MODULES=( "${SORTED_MODULES[@]}" "${MODULE_FILE}" )
      fi
    fi
  done
  MODULES=( "${SORTED_MODULES[@]}" )
}

# lets check cve-search in a background job
check_cve_search_job() {
  local EMBA_PID="${1:-}"

  if ! [[ "${EMBA_PID}" =~ [0-9]+ ]]; then
    print_output "[-] WARNING: No EMBA PID detected ... are we really running?!?"
    return
  fi

  while true; do
    if [[ -f "${LOG_DIR}"/emba.log ]]; then
      if grep -q "Test ended\|EMBA failed" "${LOG_DIR}"/emba.log 2>/dev/null; then
        break
      fi
    fi
    # shellcheck disable=SC2009
    if ! ps aux | grep -v grep | grep -q "${EMBA_PID}"; then
      break
    fi
    check_nw_interface
    check_cve_search
    sleep 90
  done
}

# $1: module group letter [P, S, L, F]
# $2: 0=single thread 1=multithread
# $3: HTML=1 - generate html file
run_modules()
{
  MODULE_GROUP="${1:-}"
  printf -v THREADING_SET '%d\n' "${2}" 2>/dev/null
  THREADING_MOD_GROUP="${THREADING_SET}"

  local SELECT_PRE_MODULES_COUNT=0

  for SELECT_NUM in "${SELECT_MODULES[@]}" ; do
    if [[ "${SELECT_NUM}" =~ ^["${MODULE_GROUP,,}","${MODULE_GROUP^^}"]{1} ]]; then
      (( SELECT_PRE_MODULES_COUNT+=1 ))
    fi
  done

  if [[ "${#SELECT_MODULES[@]}" -eq 0 ]] || [[ "${SELECT_PRE_MODULES_COUNT}" -eq 0 ]]; then
    local MODULES=()
    local MODULES_LOCAL=()
    local MODULES_EMBA=()

    mapfile -t MODULES_EMBA < <(find "${MOD_DIR}" -name "${MODULE_GROUP^^}""*_*.sh" | sort -V 2> /dev/null)
    if [[ -d "${MOD_DIR_LOCAL}" ]]; then
      mapfile -t MODULES_LOCAL < <(find "${MOD_DIR_LOCAL}" -name "${MODULE_GROUP^^}""*.sh" 2>/dev/null | sort -V 2> /dev/null)
    fi
    MODULES=( "${MODULES_EMBA[@]}" "${MODULES_LOCAL[@]}" )
    export MODULES_EXPORTED+=("${MODULES[@]}")
    if [[ ${THREADING_SET} -eq 1 && "${MODULE_GROUP^^}" != "P" ]] ; then
      sort_modules
    fi
    for MODULE_FILE in "${MODULES[@]}" ; do
      # check if "${MODULE_NAME}" is in blacklist from config directory and skip it
      MODULE_NAME=$(basename -s .sh "${MODULE_FILE}")
      if [[ " ${MODULE_BLACKLIST[*]} " =~  ${MODULE_NAME}  ]]; then
        print_output "[*] $(date) - ${MODULE_NAME} not executed - blacklist triggered " "main"
        continue
      fi
      if [[ "${SKIP_PRE_CHECKERS}" == 1 ]] && [[ "${MODULE_GROUP}" == "P" ]]; then
        print_output "[*] $(date) - ${MODULE_NAME} not executed - skip pre-checkers is set " "main"
        continue
      fi
      local MOD_FIN=0
      if ( file "${MODULE_FILE}" | grep -q "shell script" ) && ! [[ "${MODULE_FILE}" =~ \ |\' ]] ; then
        if [[ "${MODULE_GROUP^^}" == "P" ]]; then
          # we are able to enable/disable threading on module basis in the the pre-checker modules with the header:
          # export PRE_THREAD_ENA=1/0
          # shellcheck source=/dev/null
          source "${MODULE_FILE}"
          if [[ "${PRE_THREAD_ENA}" -eq 0 ]] ; then
            THREADING_SET=0
          fi
        fi
        MODULE_BN=$(basename "${MODULE_FILE}")
        MODULE_MAIN=${MODULE_BN%.*}
        # module_start_log "${MODULE_MAIN}"
        if [[ "${RESTART}" -eq 1 ]]; then
          if [[ $(grep -i -c "${MODULE_MAIN} finished" "${LOG_DIR}"/"${MAIN_LOG_FILE}") -gt 0 ]]; then
            if [[ "${MODULE_MAIN}" == "P99_"* ]] || [[ "${MODULE_MAIN}" == "L1"* ]]; then
              print_output "[*] Module ${ORANGE}${MODULE_MAIN}${NC} already finished but essential - rerun it" "main"
              MOD_FIN=0
            else
              print_output "[*] Module ${ORANGE}${MODULE_MAIN}${NC} already finished ... skipping" "main"
              MOD_FIN=1
              if [[ ${HTML} -eq 1 ]] ; then
                # we need to build the web reporter links for skipping modules
                mapfile -t LOG_FILES < <(find "${LOG_DIR}" -maxdepth 1 -type f -iname "${MODULE_MAIN}*.txt" | sort)
                for LOG_FILE_ in "${LOG_FILES[@]}"; do
                  if grep -q "nothing reported" "${LOG_FILE_}"; then
                    continue
                  fi
                  MODULE_NAME_=$(basename -s .txt "${LOG_FILE_}")
                  MODUL_NAME="$( strip_color_tags "$(grep -a -E -B 1 '[=]{65}' "${LOG_FILE_}" | head -n 1 )" | cut -d" " -f2- )"
                  HTML_FILE="${MODULE_NAME_}.html"
                  add_link_to_index "${HTML_FILE}" "${MODUL_NAME}"
                done
              fi
            fi
          fi
        fi
        if [[ "${MOD_FIN}" -eq 0 ]]; then
          if [[ ${THREADING_SET} -eq 1 ]]; then
            "${MODULE_MAIN}" &
            MOD_PID="$!"
            store_kill_pids "${MOD_PID}"
            WAIT_PIDS+=( "${MOD_PID}" )
            max_pids_protection "${MAX_MODS}" "${WAIT_PIDS[@]}"
          else
            "${MODULE_MAIN}"
          fi
        fi
        reset_module_count
      fi
      if [[ "${MODULE_GROUP^^}" == "P" ]]; then
        THREADING_SET="${THREADING_MOD_GROUP}"
      fi
    done
  else
    for SELECT_NUM in "${SELECT_MODULES[@]}" ; do
      local MOD_FIN=0
      if [[ "${SELECT_NUM}" =~ ^["${MODULE_GROUP,,}","${MODULE_GROUP^^}"]{1}[0-9]+ ]]; then
        local MODULE=""
        MODULE=$(find "${MOD_DIR}" -name "${MODULE_GROUP^^}""${SELECT_NUM:1}""_*.sh" | sort -V 2> /dev/null)
        # we need the whole module name including path in our array for later checks on it
        export MODULES_EXPORTED+=("${MODULE}")
        if ( file "${MODULE}" | grep -q "shell script" ) && ! [[ "${MODULE}" =~ \ |\' ]] ; then
          MODULE_BN=$(basename "${MODULE}")
          MODULE_MAIN=${MODULE_BN%.*}
          # module_start_log "${MODULE_MAIN}"
          if [[ "${RESTART}" -eq 1 ]]; then
            if [[ $(grep -i -c "${MODULE_MAIN} finished" "${LOG_DIR}"/"${MAIN_LOG_FILE}") -gt 0 ]]; then
              if [[ "${MODULE_MAIN}" == "P99_"* ]] || [[ "${MODULE_MAIN}" == "L1"* ]]; then
                print_output "[*] Module ${ORANGE}${MODULE_MAIN}${NC} already finished but essential - rerun it" "main"
                MOD_FIN=0
              else
                print_output "[*] Module ${ORANGE}${MODULE_MAIN}${NC} already finished ... skipping" "main"
                MOD_FIN=1
                if [[ ${HTML} -eq 1 ]] ; then
                  # we need to build the web reporter links for skipping modules
                  mapfile -t LOG_FILES < <(find "${LOG_DIR}" -maxdepth 1 -type f -iname "${MODULE_MAIN}*.txt" | sort)
                  for LOG_FILE_ in "${LOG_FILES[@]}"; do
                    if grep -q "nothing reported" "${LOG_FILE_}"; then
                      continue
                    fi
                    MODULE_NAME_=$(basename -s .txt "${LOG_FILE_}")
                    MODUL_NAME="$( strip_color_tags "$(grep -a -E -B 1 '[=]{65}' "${LOG_FILE_}" | head -n 1 )" | cut -d" " -f2- )"
                    HTML_FILE="${MODULE_NAME_}.html"
                    add_link_to_index "${HTML_FILE}" "${MODUL_NAME}"
                  done
                fi
              fi
            fi
          fi
          if [[ "${MOD_FIN}" -eq 0 ]]; then
            if [[ ${THREADING_SET} -eq 1 ]]; then
              "${MODULE_MAIN}" &
              MOD_PID="$!"
              store_kill_pids "${MOD_PID}"
              WAIT_PIDS+=( "${MOD_PID}" )
              max_pids_protection "${MAX_MODS}" "${WAIT_PIDS[@]}"
            else
              "${MODULE_MAIN}"
            fi
          fi
          reset_module_count
        fi
      elif [[ "${SELECT_NUM}" =~ ^["${MODULE_GROUP,,}","${MODULE_GROUP^^}"]{1} ]]; then
        local MODULES=()
        local MODULES_LOCAL=()
        local MODULES_EMBA=()
        mapfile -t MODULES_EMBA < <(find "${MOD_DIR}" -name "${MODULE_GROUP^^}""*_*.sh" | sort -V 2> /dev/null)
        if [[ -d "${MOD_DIR_LOCAL}" ]]; then
          mapfile -t MODULES_LOCAL < <(find "${MOD_DIR_LOCAL}" -name "${MODULE_GROUP^^}""*.sh" 2>/dev/null | sort -V 2> /dev/null)
        fi
        MODULES=( "${MODULES_EMBA[@]}" "${MODULES_LOCAL[@]}" )

        [[ ${THREADING_SET} -eq 1 ]] && sort_modules

        for MODULE_FILE in "${MODULES[@]}" ; do
          # check if "${MODULE_NAME}" is in blacklist from config directory and skip it
          MODULE_NAME=$(basename -s .sh "${MODULE_FILE}")
          if [[ " ${MODULE_BLACKLIST[*]} " =~  ${MODULE_NAME}  ]]; then
            print_output "[*] $(date) - ${MODULE_NAME} not executed - blacklist triggered " "main"
            continue
          fi
          local MOD_FIN=0
          if ( file "${MODULE_FILE}" | grep -q "shell script" ) && ! [[ "${MODULE_FILE}" =~ \ |\' ]] ; then
            if [[ "${MODULE_GROUP^^}" == "P" ]]; then
              # we are able to enable/disable threading on module basis in the the pre-checker modules with the header:
              # export PRE_THREAD_ENA=1/0
              # shellcheck source=/dev/null
              source "${MODULE_FILE}"
              if [[ "${PRE_THREAD_ENA}" -eq 0 ]] ; then
                THREADING_SET=0
              fi
            fi

            MODULE_BN=$(basename "${MODULE_FILE}")
            MODULE_MAIN=${MODULE_BN%.*}
            # module_start_log "${MODULE_MAIN}"
            if [[ "${RESTART}" -eq 1 ]]; then
              if [[ $(grep -i -c "${MODULE_MAIN} finished" "${LOG_DIR}"/"${MAIN_LOG_FILE}") -gt 0 ]]; then
                if [[ "${MODULE_MAIN}" == "P99_"* ]] || [[ "${MODULE_MAIN}" == "L1"* ]]; then
                  print_output "[*] Module ${ORANGE}${MODULE_MAIN}${NC} already finished but essential - rerun it" "main"
                  MOD_FIN=0
                else
                  print_output "[*] Module ${ORANGE}${MODULE_MAIN}${NC} already finished ... skipping" "main"
                  MOD_FIN=1
                  if [[ ${HTML} -eq 1 ]] ; then
                    # we need to build the web reporter links for skipping modules
                    mapfile -t LOG_FILES < <(find "${LOG_DIR}" -maxdepth 1 -type f -iname "${MODULE_MAIN}*.txt" | sort)
                    for LOG_FILE_ in "${LOG_FILES[@]}"; do
                      if grep -q "nothing reported" "${LOG_FILE_}"; then
                        continue
                      fi
                      MODULE_NAME_=$(basename -s .txt "${LOG_FILE_}")
                      MODUL_NAME="$( strip_color_tags "$(grep -a -E -B 1 '[=]{65}' "${LOG_FILE_}" | head -n 1 )" | cut -d" " -f2- )"
                      HTML_FILE="${MODULE_NAME_}.html"
                      add_link_to_index "${HTML_FILE}" "${MODUL_NAME}"
                    done
                  fi
                fi
              fi
            fi
            if [[ "${MOD_FIN}" -eq 0 ]]; then
              if [[ ${THREADING_SET} -eq 1 ]]; then
                "${MODULE_MAIN}" &
                MOD_PID="$!"
                store_kill_pids "${MOD_PID}"
                WAIT_PIDS+=( "${MOD_PID}" )
                max_pids_protection "${MAX_MODS}" "${WAIT_PIDS[@]}"
              else
                "${MODULE_MAIN}"
              fi
            fi
            reset_module_count
          fi
          if [[ "${MODULE_GROUP^^}" == "P" ]]; then
            THREADING_SET="${THREADING_MOD_GROUP}"
          fi
        done
      fi
    done
  fi
}

main() {
  set -a 
  trap cleaner INT

  INVOCATION_PATH="$(dirname "${0}")"

  export EMBA_PID="$$"

  # loads default values for EMBA
  export HELP_DIR="${INVOCATION_PATH}""/helpers"
  import_helper
  set_defaults

  print_ln "no_log"
  import_module

  welcome  # Print EMBA welcome message

  if [[ $# -eq 0 ]]; then
    print_output "\\n""${ORANGE}""In order to be able to use EMBA, you have to specify at least a firmware (-f)." "no_log"
    print_output "If you don't set a log directory (-l), then ./logs will be used.""${NC}" "no_log"
    print_help
    exit 1
  fi

  export EMBA_COMMAND
  EMBA_COMMAND="$(dirname "${0}")""/emba ""$*"

  emba_parameter_parsing "$@"

  print_ln "no_log"

  write_notification "EMBA starting"

  # WSL support - currently experimental!
  if [[ ${IN_DOCKER} -eq 0 ]]; then
    if grep -q -i wsl /proc/version; then
      print_bar "no_log"
      print_ln "no_log"
      print_output "[*] INFO: System running in WSL environment!" "no_log"
      print_output "[*] INFO: WSL is currently experimental." "no_log"
      print_output "[*] INFO: Please report issues to https://github.com/e-m-b-a/emba/issues." "no_log"
      print_ln "no_log"
      print_bar "no_log"
      export WSL=1
    fi
  fi

  # print it only once per EMBA run - not again from started container
  [[ ${IN_DOCKER} -eq 0 ]] && banner_printer

  if [[ ${IN_DOCKER} -eq 1 ]] ; then
    # set external path new for docker
    export EXT_DIR="/external"
    export PATH_CVE_SEARCH="${EXT_DIR}""/cve-search/bin/search.py"
  fi

  # Check all dependencies of EMBA
  dependency_check

  if [[ "${ONLY_DEP}" -eq 0 ]]; then
    if [[ "${UPDATE}" -eq 1 ]]; then
      write_notification "EMBA starts with update"
      emba_updater
      exit 0
    fi

    if [[ ${USE_DOCKER} -eq 0 && ${IN_DOCKER} -eq 0 ]]; then
      print_bar "no_log"
      print_output "[!] WARNING: EMBA running in developer mode!" "no_log"
      write_notification "WARNING: EMBA running in developer mode"
      print_bar "no_log"
    fi

    enable_strict_mode "${STRICT_MODE}" 1

    # profile handling
    if [[ -n "${PROFILE:-}" ]]; then
      if [[ -f "${PROFILE}" ]]; then
        print_bar "no_log"
        if [[ ${IN_DOCKER} -ne 1 ]] ; then
          print_output "[*] Loading EMBA scan profile with the following settings:" "no_log"
        else
          print_output "[*] Loading EMBA scan profile." "no_log"
        fi
        # all profile output and settings are done by the profile file located in ./scan-profiles/
        # shellcheck source=/dev/null
        source "${PROFILE}"
        print_output "[*] Profile ${PROFILE} loaded." "no_log"
        print_bar "no_log"
      else
        print_output "[!] Profile ${PROFILE} not found." "no_log"
        exit 1
      fi
    fi

    if [[ "${ONLY_DEP}" -eq 0 ]]; then
      # check provided paths for validity
      check_path_valid "${FIRMWARE_PATH}"
      check_path_valid "${KERNEL_CONFIG}"
      check_path_valid "${LOG_DIR}"
    fi

    # restart file gets generated during startup if old log dir is found:
    if [[ ${USE_DOCKER} -eq 1 && ${IN_DOCKER} -eq 1 ]] || [[ "${USE_DOCKER}" -eq 0 ]]; then
      if [[ -f "${TMP_DIR}"/restart ]]; then
        print_output "[!] Found restart file and backup_vars file ... trying to restart EMBA scan" "no_log"
        export RESTART=1
        rm "${TMP_DIR}"/restart
        # shellcheck source=/dev/null
        source "${LOG_DIR}""/backup_vars.log"
      fi
    fi

    # check if LOG_DIR exists and prompt to terminal to delete its content (Y/n)
    [[ ${IN_DOCKER} -eq 0 ]] && log_folder

    # create log directory, if not exists and needed subdirectories
    # do not create a log dir for dep check
    [[ "${ONLY_DEP}" -eq 0 ]] && create_log_dir

    # kernel downloader runs on the host and waits for an identified kernel version. Afterwards
    # it tries to download the kernel sources for further analysis
    if [[ ${IN_DOCKER} -eq 0 ]]; then
      kernel_downloader &
      K_DOWN_PID="$!"
      store_kill_pids "${K_DOWN_PID}"
      print_output "[*] Started kernel downloader thread with PID ${ORANGE}${K_DOWN_PID}${NC}" "no_log"
    fi

    if [[ ${IN_DOCKER} -eq 0 ]]; then
      echo "${LOG_DIR}" > "${TMP_DIR}"/orig_logdir
    fi

    if [[ "${IN_DOCKER}" -eq 0 ]]; then
      print_notification &
      NOTIFICATION_PID="$!"
      store_kill_pids "${NOTIFICATION_PID}"
      disown "${NOTIFICATION_PID}" 2> /dev/null || true
      print_output "[*] Original user: ${ORANGE}${SUDO_USER:-${USER}}${NC}" "no_log"
      print_output "[*] Notification process started with PID ${ORANGE}${NOTIFICATION_PID}${NC}" "no_log"
      echo "${SUDO_USER:-${USER}}" > "${LOG_DIR}"/orig_user.log
      echo "UID: $(id -u "${SUDO_USER:-${USER}}")" >> "${LOG_DIR}"/orig_user.log
      echo "GID: $(id -g "${SUDO_USER:-${USER}}")" >> "${LOG_DIR}"/orig_user.log
    fi

    if [[ "${IN_DOCKER}" -eq 0 ]]; then
      print_running_modules &
      RUN_MOD_PID="$!"
      store_kill_pids "${RUN_MOD_PID}"
      disown "${RUN_MOD_PID}" 2> /dev/null || true
    fi

    # Print additional information about the firmware (-Y, -X, -Z, -N)
    print_firmware_info "${FW_VENDOR}" "${FW_VERSION}" "${FW_DEVICE}" "${FW_NOTES}"
    if [[ "${KERNEL}" -ne 1 ]] && [[ "${CONTAINER_EXTRACT}" -ne 1 ]] && [[ "${ONLY_DEP}" -eq 0 ]]; then
      check_init_size
    fi

    # Now we have the firmware and log path, lets set some additional paths
    FIRMWARE_PATH="$(abs_path "${FIRMWARE_PATH}")"
    export MAIN_LOG="${LOG_DIR}""/""${MAIN_LOG_FILE}"

    # Check firmware type (file/directory)
    # copy the firmware outside of the docker and not a second time within the docker
    if [[ -d "${FIRMWARE_PATH}" ]] ; then
      PRE_CHECK=1
      print_output "[*] Firmware directory detected." "no_log"
      print_output "[*] EMBA starts with testing the environment." "no_log"
      if [[ ${IN_DOCKER} -eq 0 ]] ; then
        # in docker environment the firmware is already available
        print_output "    The provided firmware will be copied to ${ORANGE}""${FIRMWARE_PATH_CP}""/""$(basename "${FIRMWARE_PATH}")""${NC}" "no_log"
        cp -R "${FIRMWARE_PATH}" "${FIRMWARE_PATH_CP}""/""$(basename "${FIRMWARE_PATH}")"
        FIRMWARE_PATH="${FIRMWARE_PATH_CP}""/""$(basename "${FIRMWARE_PATH}")"
        export OUTPUT_DIR="${FIRMWARE_PATH_CP}"
      else
        # need to set it as fallback:
        export OUTPUT_DIR="${FIRMWARE_PATH}"
      fi
    elif [[ "${CONTAINER_EXTRACT}" -eq 1 ]]; then
      PRE_CHECK=1
      print_output "[*] Firmware analysis of docker image starting." "no_log"
      print_output "    EMBA starts with extracting the docker image ${ORANGE}${CONTAINER_ID}${NC}." "no_log"
      export FIRMWARE_PATH="${LOG_DIR}"/firmware/firmware_docker_extracted.tar
      export OUTPUT_DIR="${FIRMWARE_PATH}"
      export FIRMWARE=1
    elif [[ -f "${FIRMWARE_PATH}" ]]; then
      PRE_CHECK=1
      print_output "[*] Firmware binary detected." "no_log"
      print_output "    EMBA starts with the pre-testing phase." "no_log"
      export OUTPUT_DIR="${FIRMWARE_PATH}"
    elif [[ -f "${KERNEL_CONFIG}" && "${KERNEL}" -eq 1 ]]; then
      print_output "[*] Kernel configuration file detected." "no_log"
    else
      print_output "[!] Invalid firmware file" "no_log"
      print_help
      exit 1
    fi

    # calculate the maximum modules are running in parallel
    if [[ ${THREADED} -eq 1 ]] && [[ "${MAX_MODS}" -eq 0 ]]; then
      # the maximum modules in parallel
      # rule of thumb - per core half a module, minimum 2 modules
      MAX_MODS="$(( "$(grep -c ^processor /proc/cpuinfo)" /2 +1))"

      # if we have only one core we run two modules in parallel
      if [[ "${MAX_MODS}" -lt 2 ]]; then
        MAX_MODS=2
      fi
      export MAX_MODS
    fi

    # calculate the maximum threads per module
    if [[ ${THREADED} -eq 1 ]] && [[ "${MAX_MOD_THREADS}" -eq 0 ]]; then
      # the maximum threads per modules - if this value does not match adjust it via
      # local MAX_MOD_THREADS=123 in module area
      export MAX_MOD_THREADS="$(( 2* "$(grep -c ^processor /proc/cpuinfo)" ))"
    fi

    # setup non threaded mode:
    if [[ ${THREADED} -eq 0 ]]; then
      export MAX_MODS=1
      export MAX_MOD_THREADS=1
    fi
    print_output "    EMBA is running with ${ORANGE}${MAX_MODS}${NC} modules in parallel and ${ORANGE}${MAX_MOD_THREADS}${NC} threads per module." "no_log"

    # Change log output to color for web report and prepare report
    if [[ ${HTML} -eq 1 ]] ; then
      if [[ ${FORMAT_LOG} -eq 0 ]] ; then
        FORMAT_LOG=1
        print_output "[*] Activate colored log for webreport" "no_log"
      fi
      print_output "[*] Prepare webreport" "no_log"
      prepare_report
    fi

    if [[ ${LOG_GREP} -eq 1 ]] ; then
      # Create grep-able log file
      create_grep_log
      write_grep_log "sudo ""${EMBA_COMMAND}" "COMMAND"
    fi

    if [[ "${KERNEL}" -ne 1 ]] && [[ ${FIRMWARE} -eq 1 ]]; then
      # Exclude paths from testing and set EXCL_FIND for find command (prune paths dynamicially)
      set_exclude
    fi

    #######################################################################################
    # Kernel configuration check
    #######################################################################################
    if [[ "${KERNEL}" -eq 1 ]]; then
      if [[ ${IN_DOCKER} -eq 1 ]] && [[ -f "${LOG_DIR}"/kernel_config ]]; then
        export KERNEL_CONFIG="${LOG_DIR}"/kernel_config
      fi

      if ! [[ -f "${KERNEL_CONFIG}" ]] ; then
        print_output "[-] Invalid kernel configuration file: ${ORANGE}${KERNEL_CONFIG}${NC}" "no_log"
        exit 1
      else
        if [[ ${IN_DOCKER} -eq 0 ]] ; then
          # we copy the kernel config file from outside the container into our log directory
          # further modules are using LOG_DIR/kernel_config for accessing the kernel config
          if [[ -d "${LOG_DIR}" ]] ; then
            cp "${KERNEL_CONFIG}" "${LOG_DIR}"/kernel_config
          else
            print_output "[!] Missing log directory" "no_log"
            exit 1
          fi
        fi
      fi
    fi

    if [[ ${IN_DOCKER} -eq 0 ]] ; then
      check_cve_search_job "${EMBA_PID}" &
      local TMP_PID="$!"
      store_kill_pids "${TMP_PID}"
      disown "${TMP_PID}" 2> /dev/null || true
    fi

    disk_space_monitor "${EMBA_PID}" &
    local TMP_PID="$!"
    store_kill_pids "${TMP_PID}"
    disown "${TMP_PID}" 2> /dev/null || true

    # if $CONTAINER_EXTRACT is set we extract the docker container with id $CONTAINER_ID outside of the
    # EMBA container into log directory
    # we do this outside of the EMBA container - otherwise we will not reach the docker environment
    if [[ "${CONTAINER_EXTRACT}" -eq 1 && "${IN_DOCKER}" -eq 0 ]] ; then
      docker_container_extractor "${CONTAINER_ID}"
    fi
  fi

  #######################################################################################
  # Docker
  #######################################################################################
  if [[ ${USE_DOCKER} -eq 1 ]] ; then
    if ! [[ ${EUID} -eq 0 ]] ; then
      if ! groups | grep -qw docker; then
        print_output "[!] Using EMBA with docker-compose requires root permissions" "no_log"
        print_output "$(indent "Run EMBA with root permissions or add your user to docker group")" "no_log"
        print_output "$(indent "e.g., sudo usermod -aG docker [non-root user]")" "no_log"
        exit 1
      fi
    fi
    if ! command -v docker-compose > /dev/null ; then
      print_output "[!] No docker-compose found" "no_log"
      print_output "$(indent "Install docker-compose via apt-get install docker-compose to use EMBA with docker")" "no_log"
      exit 1
    fi

    OPTIND=1
    ARGUMENTS=()
    while getopts a:A:BcC:d:De:Ef:Fghijk:l:m:N:op:P:QrsStT:UX:yY:WxzZ: OPT ; do
      case ${OPT} in
        D|f|i|l)
          ;;
        *)
          if [[ -v OPTARG[@] ]] ; then
            ARGUMENTS=( "${ARGUMENTS[@]}" "-${OPT}" "${OPTARG[@]}" )
          else
            ARGUMENTS=( "${ARGUMENTS[@]}" "-${OPT}" )
          fi
          ;;
      esac
    done

    print_ln "no_log"

    print_output "[*] EMBA sets up the docker environment.\\n" "no_log"

    # try it 10 times before exit
    local CNT_DOCK=0
    for CNT_DOCK in {1..10}; do
      if ! docker images | grep -qE "emba[[:space:]]*latest"; then
        sleep 1
      else
        break
      fi
      if [[ "$CNT_DOCK" -ge 10 ]]; then
        print_output "[-] EMBA docker environment not ready!" "no_log"
        exit 1
      fi
    done

    print_output "[*] EMBA initializes docker container.\\n" "no_log"

    if [[ "${ONLY_DEP}" -eq 0 ]]; then
      # store some details that we do not have in the docker container:
      echo "${FIRMWARE_PATH}" >> "${TMP_DIR}"/fw_name.log
      echo "${LOG_DIR}" >> "${TMP_DIR}"/emba_log_dir.log
      echo "${EMBA_COMMAND}" >> "${TMP_DIR}"/emba_command.log
    fi

    write_notification "EMBA starting docker container"

    [[ "${STRICT_MODE}" -eq 1 ]] && set +e

    disable_strict_mode "${STRICT_MODE}" 0
    if [[ "${ONLY_DEP}" -gt 0 ]]; then
      EMBA="${INVOCATION_PATH}" FIRMWARE="${FIRMWARE_PATH}" docker-compose run --rm emba -c './emba -f /firmware -i "$@"' _ "${ARGUMENTS[@]}"
      D_RETURN=$?
    else
      EMBA="${INVOCATION_PATH}" FIRMWARE="${FIRMWARE_PATH}" LOG="${LOG_DIR}" docker-compose run --rm emba -c './emba -l /logs -f /firmware -i "$@"' _ "${ARGUMENTS[@]}"
      D_RETURN=$?
    fi
    enable_strict_mode "${STRICT_MODE}" 0

    if [[ "${D_RETURN}" -eq 0 ]] ; then
      if [[ "${ONLY_DEP}" -eq 0 ]] ; then
        print_output "[*] EMBA finished analysis in docker container.\\n" "no_log"
        write_notification "EMBA finished analysis in default mode"
        print_output "[*] Firmware tested: ${ORANGE}${FIRMWARE_PATH}${NC}" "no_log"
        print_output "[*] Log directory: ${ORANGE}${LOG_DIR}${NC}" "no_log"
        if [[ -v HTML_PATH ]] && [[ -f "${HTML_PATH}"/index.html ]]; then
          print_output "[*] Open the web-report with${ORANGE} firefox $(abs_path "${HTML_PATH}/index.html")${NC}\\n" "main"
        fi
        cleaner 0
      else
        # we do not need the log dir from dependency checker
        [[ -d "${LOG_DIR}" ]] && rm -rf "${LOG_DIR}"
      fi
      exit 0
    else
      print_output "[-] EMBA failed in docker mode!" "main"
      cleaner 0
      write_notification "EMBA failed analysis in default mode"
      exit 1
    fi
  fi

  #######################################################################################
  # Start status bar
  if [[ ${DISABLE_STATUS_BAR} -eq 0 ]] ; then
    initial_status_bar
    # Trap the window resize signal (handle window resize events).
    trap 'initial_status_bar' WINCH
  fi

  #######################################################################################
  # Pre-Check (P-modules)
  #######################################################################################
  if [[ "${PRE_CHECK}" -eq 1 ]] ; then

    print_ln "no_log"
    if [[ -d "${LOG_DIR}" ]]; then
      print_output "[!] Pre-checking phase started on ""$(date)""\\n""$(indent "${NC}""Firmware binary path: ""${FIRMWARE_PATH}")" "main"
    else
      print_output "[!] Pre-checking phase started on ""$(date)""\\n""$(indent "${NC}""Firmware binary path: ""${FIRMWARE_PATH}")" "no_log"
    fi
    write_notification "Pre-checking phase started"

    # 'main' functions of imported modules
    # in the pre-check phase we execute all modules with P[Number]_Name.sh

    run_modules "P" "${THREADED}" "0"

    # if we running threaded we ware going to wait for the slow guys here
    [[ ${THREADED} -eq 1 ]] && wait_for_pid "${WAIT_PIDS[@]}"

    print_ln "no_log"

    if [[ -d "${LOG_DIR}" ]]; then
      print_output "[!] Pre-checking phase ended on ""$(date)"" and took about ""$(date -d@"${SECONDS}" -u +%d:%H:%M:%S)"" \\n" "main"
    else
      print_output "[!] Pre-checking phase ended on ""$(date)"" and took about ""$(date -d@"${SECONDS}" -u +%d:%H:%M:%S)"" \\n" "no_log"
    fi
    write_notification "Pre-checking phase finished"

    # useful prints for debugging:
    # print_output "[!] Firmware value: ${FIRMWARE}"
    # print_output "[!] Firmware path: ${FIRMWARE}_PATH"
    # print_output "[!] Output dir: $OUTPUT_DIR"
    # print_output "[!] LINUX_PATH_COUNTER: $LINUX_PATH_COUNTER"
    # print_output "[!] LINUX_PATH_ARRAY: ${#ROOT_PATH[@]}"
  fi

  #######################################################################################
  # Firmware-Check (S modules)
  #######################################################################################
  WAIT_PIDS=()
  if [[ ${FIRMWARE} -eq 1 ]] ; then
    print_output "\n=================================================================\n" "no_log"

    if [[ -d "${LOG_DIR}" ]]; then
      print_output "[!] Testing phase started on ""$(date)""\\n""$(indent "${NC}""Firmware path: ""${FIRMWARE_PATH}")" "main" 
    else
      print_output "[!] Testing phase started on ""$(date)""\\n""$(indent "${NC}""Firmware path: ""${FIRMWARE_PATH}")" "no_log"
    fi
    write_notification "Testing phase finished"
    write_grep_log "$(date)" "TIMESTAMP"

    run_modules "S" "${THREADED}" "${HTML}"

    [[ ${THREADED} -eq 1 ]] && wait_for_pid "${WAIT_PIDS[@]}"

    print_ln "no_log"

    if [[ -d "${LOG_DIR}" ]]; then
      print_output "[!] Testing phase ended on ""$(date)"" and took about ""$(date -d@"${SECONDS}" -u +%d:%H:%M:%S)"" \\n" "main"
    else
      print_output "[!] Testing phase ended on ""$(date)"" and took about ""$(date -d@"${SECONDS}" -u +%d:%H:%M:%S)"" \\n" "no_log"
    fi
    write_notification "Testing phase ended"

    TESTING_DONE=1
  fi

  #######################################################################################
  # Live Emulation - Check (L-modules)
  #######################################################################################
  if [[ "${FULL_EMULATION}" -eq 1 ]] ; then
    print_output "\n=================================================================\n" "no_log"
    if [[ -d "${LOG_DIR}" ]]; then
      print_output "[!] System emulation phase started on ""$(date)""\\n""$(indent "${NC}""Firmware path: ""${FIRMWARE_PATH}")" "main" 
    else
      print_output "[!] System emulation phase started on ""$(date)""\\n""$(indent "${NC}""Firmware path: ""${FIRMWARE_PATH}")" "no_log"
    fi
    write_notification "System emulation phase started"

    write_grep_log "$(date)" "TIMESTAMP"
    # these modules are not threaded!
    run_modules "L" "0" "${HTML}"

    print_ln "no_log"
    if [[ -d "${LOG_DIR}" ]]; then
      print_output "[!] System emulation phase ended on ""$(date)"" and took about ""$(date -d@"${SECONDS}" -u +%d:%H:%M:%S)"" \\n" "main"
    else
      print_output "[!] System emulation ended on ""$(date)"" and took about ""$(date -d@"${SECONDS}" -u +%d:%H:%M:%S)"" \\n" "no_log"
    fi
    write_notification "System emulation phase ended"
  fi

  #######################################################################################
  # Reporting (F-modules)
  #######################################################################################
  if [[ -d "${LOG_DIR}" ]]; then
    print_output "[!] Reporting phase started on ""$(date)""\\n" "main" 
  else
    print_output "[!] Reporting phase started on ""$(date)""\\n" "no_log" 
  fi
  write_notification "Reporting phase started"
 
  run_modules "F" "0" "${HTML}"

  [[ ${DISABLE_STATUS_BAR} -eq 0 ]] && remove_status_bar

  write_notification "Reporting phase ended"

  if [[ "${TESTING_DONE}" -eq 1 ]]; then
    if [[ "${FINAL_FW_RM}" -eq 1 && -d "${LOG_DIR}"/firmware ]]; then
      print_output "[*] Removing temp firmware directory\\n" "no_log" 
      rm -r "${LOG_DIR}"/firmware 2>/dev/null
    fi
    if [[ "${FINAL_FW_RM}" -eq 1 && -d "${LOG_DIR}"/p61_unblob_eval/unblob_extracted ]]; then
      print_output "[*] Removing unblob firmware directory\\n" "no_log"
      rm -r "${LOG_DIR}"/p61_unblob_eval/unblob_extracted 2>/dev/null
    fi
    print_ln "no_log"
    if [[ -d "${LOG_DIR}" ]]; then
      print_output "[!] Test ended on ""$(date)"" and took about ""$(date -d@"${SECONDS}" -u +%d:%H:%M:%S)"" \\n" "main"
      write_notification "EMBA finished analysis"
      rm -r "${TMP_DIR}" 2>/dev/null || true
    else
      print_output "[!] Test ended on ""$(date)"" and took about ""$(date -d@"${SECONDS}" -u +%d:%H:%M:%S)"" \\n" "no_log"
    fi
    write_grep_log "$(date)" "TIMESTAMP"
    write_grep_log "$(date -d@"${SECONDS}" -u +%d:%H:%M:%S)" "DURATION"
  else
    print_output "[!] No extracted firmware found" "no_log"
    print_output "$(indent "Try using binwalk or something else to extract the firmware")"
    exit 1
  fi

  [[ "${HTML}" -eq 1 ]] && update_index

  if [[ -f "${HTML_PATH}"/index.html ]] && [[ "${IN_DOCKER}" -eq 0 ]]; then
    print_output "[*] Web report created HTML report in ${ORANGE}${LOG_DIR}/html-report${NC}\\n" "main"
    print_output "[*] Open the web-report with${ORANGE} firefox $(abs_path "${HTML_PATH}/index.html")${NC}\\n" "main"
  fi

  # we need to change the permissions of the LOG_DIR to the orig. user from the host
  [[ "${IN_DOCKER}" -eq 1 ]] && restore_permissions
  cleaner 0
  exit 0
}

main "$@"
